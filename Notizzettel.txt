=======================

Modern C++

Peter Loos

Entwicklung / Schulung

C/C++, Java, C#, Mobile Progr.  , JavaScript

Back to the Roots: C++

Guten Morgen

=======================

2 Tools:

== Visual Studio

== Github

=======================

Agenda:

Was sind meine Erwartungen:

== Überblick
== Die Themen  XXX müssen drin sein
== ...
== Multithreading: Yes / No.


-- Von C++ Classic nach Modern C++
-- Unit Test Konzepte
-- Alles was Neu ist :)
-- 


=======================

To Do Liste:

emplace... - Funktionen  // Morgen (Templates)

noexcept

std::function - check

std::bind

=======================

== C++ ist eine der, wenn nicht die schwierigste Programmiersprache am Markt.

== C ++ 17 / 20  // Online Compiler

=======================

Was ist eine Referenz:

C++: Referenz: Ähnlich

i)  Alias-Name für ein vorhandenes Objekt / Variable

ii) Hinter den Kulissen: Adresse.

Ähnlichkeiten zum Pointer:

int& n = m;   // ERROR // Keine Null-Referenz

Hauptgrund: Keine KOPIE.

a + b: Ist ein temp. Objekt // es hat KEINEN Namen.

Ab C++ 11:

Es gibt einen ZWEITEN Referenz Typ:

Dieser steht für temp. Objekte.

Syntax: &&

========================================

Move Semantik:

... 480    // temp. Objekt // wird freigegeben
... 100    // Im Vector

Ab C++ 11: Lösung: Move-Semantik




... 550


Frage:

Warum ist der Kopier-Konstruktor vorhanden ???

https://github.com/pelocpp/cpp_clean_performant_secure/blob/master/Clean_Performant_Code/Guidelines/Guidelines_Core_Cpp.md#link8

=========

... 2C0

========

Rule-of-Three:

Zwingend notwendig, wenn Pointer (new / delete) in der Klasse
vorhanden sind.

Wenn nicht:

class Point
{
public:
    int m_x;
    int m_y;
};

Für so eine Klasse muss ich KEINE Spezialmethode realisieren.

==========================================================

C++:

Viele neue Sachen :)

Aber:

Vieles wird auf schon Vorhandenes abgebildet !

zB: Lambda.

"Schon Vorhandene:"   ==> Aufrufbares Objekt
                      Klasse, die den operator() implementiert.

                      ==> Lokale Klassen in einer Funktion, die den operator() implementieren.

Aufrufbares Objekt:

Wozu ???????????????????????????

Sie treten in Erscheinung:

a) bei STL - Algorithmen
b) bei Lambdas
c) bei std::variant
d) sicherlich noch mehr 

Why:  Hmmm: operator() schön .. ist ja wie eine Methode zu sehen:

Wozu operator()  Hmm, ist eine Methode OHNE Namen :)

Sortieren:  compare  ==> In der Doku müsste compare beschrieben werden.

Bei operator() müssen nur noch die Parameter beschrieben werden.

=========================================

Lambda:   Sortieren.

std::sort

Vergleichskriterium:

A) Globale Funktion

B) Aufrufbares Objekt

====================================

Ist Referenz egal oder nicht ??????????????

NICHT:  Syntax.

ABER:   Performanz.

Wie ????

        bool operator() (int n1, int n2) const {

            int z = n1;
00007FF60E7F25CA  mov         eax,dword ptr [n1]  
00007FF60E7F25D0  mov         dword ptr [z],eax  
            int y = n2;
00007FF60E7F25D3  mov         eax,dword ptr [n2]  
00007FF60E7F25D9  mov         dword ptr [y],eax  

        bool operator() (const int& n1, const int& n2) const {

            int z = n1;
00007FF7EA8B8DAB  mov         rax,qword ptr [n1]  
00007FF7EA8B8DB2  mov         eax,dword ptr [rax]  
00007FF7EA8B8DB4  mov         dword ptr [z],eax  
            int y = n2;
00007FF7EA8B8DB7  mov         rax,qword ptr [n2]  
00007FF7EA8B8DBE  mov         eax,dword ptr [rax]  
00007FF7EA8B8DC0  mov         dword ptr [y],eax  

Fazit:

A) Elementare Variablen:

   i) Normalfall: Bin am Wert interessiert: Call by Value / Copy // SCHNELL // KEINE Referenz

   ii) Zweiter Fall: Bin am Original interessiert:
   
           Call by Referenz  // Langsamer // Könnte Original ÄNDERN 
                               oder schützen: const

B) Objekte:

 Sind groß, will man NICHT kopieren ========> Go for &

 ========================================================

 Cpp Insights

 Capture Clause

 ========================================================

 Einem Lambda ist eine Klasse zugeordnet:

 Cpp Insights

 https://cppinsights.io/

========================================================

    struct Struct
    {
        int m_i;
        int m_j;
    };

Die ganze Geschichte:

==============================================

Pause:

std::initializer_list

2 Exercises.

==============================================

std::vector               ====> Daten:  HEAP

std::initializer_list     ====> Daten:  STACK

std::list

=============================================

Aufgabe:

Aufgaben zur Move-Semantik

Einfache Realisierung einer Lambda-Funktion.


=============================================

Weiter:

Besprechung

Smart Pointer

Algorithmen

===================================

auto:

a) Vereinbarung von Variablen

b) auto als Rückgabetyp

c) auto als Parameter

================================================

STL // Container // Algorithmen // Iteratoren

Von Grund auf betrachten ...

Go - for STL // Container // Algorithmen // Iteratoren


13 => 19 => 28 => 42 => 63

Algorithmus:  Neue Länge = Alte Länge * 1.5;  // Mit int-Arithmetik 
                                              // abrunden

================================================

Person p;

C#:   Was ist "Person p;" in C# ???

      Person p = new Person (...);


C++:  Was ist "Person p;" in C++ ???

      Ein komplettes Person Objekt !!!

      Ginge aus:

      Person* p = new Person (...);


In der Tat:

C++ ist deshalb komplexer als C#:

C#:   Referenz-Semantik   (Ausnahme:  struct )

C++:

      Value-Semantik         // Wert-Semantik  // Stack
      Dynamische-Semantik    // Heap

// ==============================================

Konzept der STL:

STL Container             (std::vector)

===> Zugriff auf die Elemente eines Containers

Geht bei manchen Container mit operator[]:

   Sind die sequentiellen Container:
    std::vector
    std::array

STL Container // Zugriff: Transparenz // Austauschbarkeit:

Lösung // Ansatz:

A) STL Container

B) STL Konzept: Position eines Elements in einem Container: Iterator.

B1) Mit diesen Positionen kann man auf JEDEN STL Container zugreifen.

   Position: STL Iterator // Synonym: Position.

C) STL - Algorithmen  // einfache Vorgänge

KONZEPT:   Losen Kopplung

STL Container <=> STL Iteratoren <=> STL Algorithmus


================================================


Was ist using:

using iterator

Wie typedef a la C

========================================

std::make_move_iterator

========================================


Frage: 

Kann man solche Iterationen auch selbst schreiben:

Ja !!!

========================================

for_each

Container c;

for_each (auto elem : c) {
}

Gibt es auch in C++:

Hinweis:
Das KONZEPT der  Losen Kopplung
STL Container <=> STL Iteratoren <=> STL Algorithmus
wurde hiermit über den Haufen geworfen.

// Warum sollten wir Algorithmen einsetzen ??????????????????

Beispiel: Vorbelegung eines Containers.

=====================================

Suchen eines Elements in einem Feld // Container:

for (int i = 0; i < Size(); ++i) {

    if (Container[i] == zuSuchendesElement) {
        break;
    }
}

std::find_if:   Bauerntrick

========================================================

Smart Pointer:
=============

new / delete

int* ptr = new int();
<== ptr übergebe man in die Obhut eines Hüllenobjekts.

Was ist das Problem von / mit new?

Wir vergessen das delete!

Idee:

i) OO

ii) Klassen: Konstruktoren und Destruktoren

iii) Destruktoren: Wann werden die aufgerufen?

     Am Ende des Scopes

     {
         Person p;
         int* ptr;
         Wrapper um einen Zeiger;


     }   // automatisch: Destruktor an p aufgerufen.  // Determinismus

iv)  Objekte und Zeiger zusammenführen:
     Wir betrachten Hüllenobjekte um Zeiger:

     Konstruktor   ==> new
     Destruktor    ==> delete

Grundprinzip:      std::auto_ptr

Verfeinerungen: Haben unterschiedliche Strategien

i) std::unique_ptr

ii) std::shared_ptr / std::weak_ptr

Strategie std::unique_ptr:

Ein std::unique_ptr - Objekt kann zu EINEM Zeitpunkt im Programm nur EINMAL
vorhanden sein.   // man kann das nicht kopieren. // Aber: verschieben !!!!!!!

Strategie std::shared_ptr:

Ein std::shared_ptr - Objekt kann zu EINEM Zeitpunkt im Programm MEHRERE
Besitzer haben.   // man kann es kopieren.

Destruktor: Zu betrachten ....

// Schwache Ähnlichkeiten zum GC Prinzip.

// ====================================================

Wehrmutstropfen:

std::shared_ptr funktioniert nicht immer !!!!!!!!!!!!!!!! WTF

Lösung:

std::weak_ptr:

Whyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy ?

Haben wir zyklische Referenzen ?????????????

Beispiel:

Observer - Pattern ???

Beobachten:

Ziel-Objekt: Zustand // der kann sich ändern

Client-Objekt: Diese interessieren sich für einen Zustandswechsel am Ziel-Objekt.

Aussagen:

== Ein (mehrere) Client-Objekt kennen das Ziel-Objekt.

== Ein Client-Objekt kann sich zu diesem Zweck am Ziel-Objekt anmelden (register // attach).

== Ein Ziel-Objekt kennt ein (mehrere) Client-Objekte, die sich angemeldet haben.


Client-Objekt: kennt Ziel-Objekt.

Ziel-Objekt: kennt Client-Objekte.

Fazit:

Client-Objekte:   std::shared_ptr

Ziel-Objekt:      std::shared_ptr

Im Ziel-Objekt gibt es eine Liste für die Client-Objekte:

std::list  <  XXX  >   XXX = std::weak_ptr

          Folge:       client.lock ()    <====== nullptr


In der Zukunft:  std::shared_ptr  verwendest   <=============

   Könnte das auch ein weak_ptr sein ??????????

   Will ich beim Kopieren eines std::shared_ptr ein weiterer Besitzer sein ???????????

Wie schaffe ich das in C#  ????

Events:   +=  oder -=  abmelden.

Delegates:  Wo kein -=:  Referenz-Count geht nicht auf 0.

==========================================================

const 

constexpr

Problem:   Wie / wo kann man dieses Feature in der Praxis einsetzen ???

Embedded Programmer:

Vieles kann man aus der kritischen Laufzeit (statischen Tabellen) rausziehen.

in C#:

https://github.com/dotnet/roslyn/issues/15079

=======================================================

Smart Pointer:
=============




